Android Framework
    o Applications
        ? Alarm, Browser, Calculator, Calender, Camera, Clock, Contacts, Dialer, Email, Home,
          IM, MediaPlayer, Photo Album, SMS/MMS, Voice Dial ..
    o Android Framework
        ? Content provider, View System, Managers (Activity, Window, Notification, Package, Telephony, Resource, Location)
    o Native Libraries + Android Runtime
        ? Audio Manager, OpenGL/ES, SQLITE, surface Manager, Web kit   + Core Libraries, Dalvik VM
    o HAL (Hardware Abstraction Layer)
        ? Audio, Bluetooth, CAmer, DRM, External Storage, Graphics, input, media, sensors, Tv
    o Linux Kernel
        ? Drivers (Audio Binder (IPC)),Bluetooth, Camera, Display Keypad, shared Memory, USB, WIFI, Power Management



1. Android Component
    o Activity
An activity represents a single screen in your app with an interface the user can interact with.

To implement an Activity in your app, do the following: 
•	Create an Activity Java class.
•	Implement a basic UI for the Activity in an XML layout file.
•	Declare the new Activity in the AndroidManifest.xml file. 
	
        ? Activity Lifecycle
            •	onCreate()   (the only Activity method that must be implemented)
                    • Must be implemented
                    • Call setContentView()
                    • Initialize display layout
                    • Initialize variables
                    • Start Background Thread
            •	onStart()
                    • Register Broadcast Receiver
                    • Reinitialize states
            •	onRestart()
                    • Open server connections
                    • Allocate Resources
            •	onResume()
                    • Register Broadcast Receivers
                    • Restore variables
                    • Restart animations
                    • lightweight code
            •	--------------- Activity running
            •	onPause()
                    • commit changes
                    • save variables
                    • save preferences
                    • stop animations
                    • unregister BroadcastReceivers
                    • lightweight code
            •	onStop()
                    • close server connections
                    • free resources
                    • unregister Broadcast receiver
            •	onDestroy()
                    • close Databases
                    • Release Remaining resources
                    • Stop Background Thread



         Fragment Life Cycle

1. FragmentActivity: The base class for all activities using compatibility based Fragment (and loader) features.

2. Fragment: The base class for all Fragment definitions

3. FragmentManager: The class for interacting with Fragment objects inside an activity

4. FragmentTransaction: The class for performing an atomic set of Fragment operations such as Replace or Add a Fragment.


        o Tasks & Back Stack 
		(Launch mode)

    ? standard - The default behavior. Creates a new instance of the activity in the task.
        • Default : Yes
        • Instantiation : Everytime an intent is created, a new instance is created.
                        Also instances can be member of multiple tasks and more than one instance in a Task.
        • New Task on Launch : No. Open in the same Task that originated the intent
        • Allow other activities within Task : Yes

    ? singleTop - Reuse an activity instance if already at the top of the stack; otherwise create new instance.
        • Default : No
        • Instantiation : Exactly like standard but if the activity is at the top of the Task stack
                        then it uses the existing instance.
        • New Task on Launch : No. Open in the same Task that originated the intent
        • Allow other activities within Task : Yes
        • singleTop - While there can be multiple instances of the BrowserBookmarksPage if there is already
        one at the top of the task's activity stack it will be reused. This way you only have to hit back once
        to return to the browser if the bookmarks activity is started multiple times.


    ? singleTask - Reuse an activity instance if exists in an existing stack; otherwise create in a new task stack.
        • Default : No
        • Instantiation : Single instance
        • New Task on Launch : Yes. Always a Root Task.
        • Allow other activities within Task : Yes
        • singleTask - There is only one BrowserActivity at a time and it doesn't become part of tasks
        that send it intents to open web pages. While it might return to whatever most recently launched
        it when you hit back it is actually fixed at the bottom of its own task activity stack.

    ? singleInstance - Same as singleTask but no other activities are ever inserted into the created task stack.
        • Default : No
        • Instantiation : Single instance
        • New Task on Launch : Yes. Always a Root Task.
        • Allow other activities within Task : Never. Always the only activity in the task
        • singleInstance - Only one AlarmAlert activity at a time and it is always its own task.
        Anything it might launch (if anything) becomes a part of a separate task stack.

        •	FLAG_ACTIVITY_CLEAR_TASK - Clear any existing tasks on this stack before starting the activity.
        •	FLAG_ACTIVITY_NEW_TASK - Start the activity in a new task or reuse an existing task tied to that activity.
        •	FLAG_ACTIVITY_SINGLE_TOP - If the activity being started is the same as the current activity, then reuses
                                        the existing instance which receives a call to onNewIntent()
        •	FLAG_ACTIVITY_CLEAR_TOP - If the activity being started is already running in the current task, delivers us back
                                        to the existing instance and clears the stack.
        There are almost a dozen other flags you can set as well, for example
        FLAG_ACTIVITY_BROUGHT_TO_FRONT,
        FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS, and
        FLAG_ACTIVITY_MULTIPLE_TASK ...


    o Service
         •	Foreground Service
		 Foreground services are those services that are visible to the users. 
		 The users can interact with them at ease and track what’s happening. 
		 These services continue to run even when users are using other applications.
			The perfect example of this is Music Player and Downloading.
		 
         •	Background Service
		These services run in the background, such that the user can’t see or access them. 
		These are the tasks that don’t need the user to know them.
		Syncing and Storing data can be the best example.
		 
         •	Bound Service
		 Bound service runs as long as some other application component is bound to it. 
		 Many components can bind to one service at a time, but once they all unbind, the service will destroy.
		 To bind an application component to the service, bindService() is used.
		 
		 • Lifecycle of Android Services
		 	 
			Started Service: A service becomes started only when an application component calls startService(). 
							It performs a single operation and doesn’t return any result to the caller. 
							Once this service starts, it runs in the background even if the component that created it destroys. 
							This service can be stopped only in one of the two cases:
								• By using the stopService() method.
								• By stopping itself using the stopSelf() method.

			
			Bounded Service: A service is bound only if an application component binds to it using bindService().
							It gives a client-server relation that lets the components interact with the service. 
							The components can send requests to services and get results.
		
		Methods of Android Services 
			
			• onStartCommand()
				The system calls this method whenever a component, say an activity requests ‘start’ to a service, using startService().
				Once we use this method it’s our duty to stop the service using stopService() or stopSelf().
				
			• onBind()
				This is invoked when a component wants to bind with the service by calling bindService(). 
				In this, we must provide an interface for clients to communicate with the service. 
				For interprocess communication, we use the IBinder object.
				
				It is a must to implement this method. If in case binding is not required, 
				we should return null as implementation is mandatory.
				
			• onCreate()
				This is the first callback method that the system calls when a new component starts the service. 
				We need this method for a one-time set-up.
			
			• onUnbind()
				The system invokes this when all the clients disconnect from the interface published by the service.
				
			• onDestroy()
				This method is the final clean up call for the system. The system invokes it just before the service destroys. 
				It cleans up resources like threads, receivers, registered listeners, etc.
			
			• onRebind()
				The system calls this method when new clients connect to the service. The system calls it after the onBind() method.

		
		 
		 
		 
         •	Android Interface Definition Language (AIDL)

         • IntentService
        IntentService is a base class for Services that handle asynchronous requests (expressed as Intents) on demand.
        Clients send requests through startService(Intent) calls; the service is started as needed,
        handles each Intent in turn using a worker thread, and stops itself when it runs out of work.
		
		Certain important features of Intent are :

    It queues up the upcoming request and executes them one by one.
    Once the queue is empty it stops itself, without the user’s intervention in its lifecycle.
    It does proper thread management by handling the requests on a separate thread.



    o Broadcast Receiver
         • static receiver : To register a receiver statically, use the <receiver> element in your AndroidManifest.xml file.
                             Static receivers are also called manifest-declared receivers.
         • dynamic receiver : To register a receiver dynamically, use the app context or activity context.
                              The receiver receives broadcasts as long as the registering context is valid, meaning
                              as long as the corresponding app or activity is running.
                              Dynamic receivers are also called context-registered receivers.

    o Content Provider
        A ContentProvider provides data from one application to another, when requested.
        It manages access to a structured set of data. It provides mechanisms for defining data security.
        ContentProvider is the standard interface that connects data in one process with code running in another process.

-----------------------------------------------------------------
        Broadcasts are messages that the Android system and Android apps send when
        events occur that might affect the functionality of other apps.
        There are two types of broadcasts:
            System broadcasts are delivered by the system.
            Custom broadcasts are delivered by your app.

    Android provides three ways for your app to send custom broadcasts:
    •  Normal broadcasts are asynchronous. Receivers of normal broadcasts run in an undefined order, often at the same time.
                        To send a normal broadcast, create a broadcast intent and pass it to sendBroadcast(Intent).
    •  Local broadcasts are sent to receivers that are in the same app as the sender.
                        To send a local broadcast, create a broadcast intent and pass it to LocalBroadcastManager.sendBroadcast.
    •  Ordered broadcasts are delivered to one receiver at a time. As each receiver executes, it can propagate a result to the next receiver,
                        or it can cancel the broadcast so that the broadcast is not passed to other receivers.
                        To send an ordered broadcast, create a broadcast intent and pass it to sendOrderedBroadcast(Intent, String).

-----------------------------------------------------------------

    o  Intent :
    An intent is a message that can be thought of as a request that is
    given to either an activity within your own app, an external application, or a built-in Android service.
        •	Explicit Intents : An "explicit" intent is used to launch other activities within your application.
        •	Implicit Intents : Implicit Intents are requests to perform an action based on a desired action and target data.
                               Phone Call, Send Email (to Phone Email Client), Send Email (to Gmail), Launch Website, Open Google Play Store
                               Compose SMS, Google Maps, Capture Photo, Sharing Content
        •	PendingIntent is a token that you give to another application (e.g. Notification Manager, Alarm Manager or other 3rd party applications),
         which allows this other application to use the permissions of your application to execute a predefined piece of code.
        To perform a broadcast via a pending intent so get a PendingIntent via PendingIntent.getBroadcast().
        To perform an activity via an pending intent you receive the activity via PendingIntent.getActivity().

-----------------------------------------------------------------
    o Notifications
              A notification is a message you can display to the user outside of your application's normal UI.
              Notifications appear in the phone's notification area and then can be expanded to see more information.

            At the minimum, all notifications consist of a base layout including:
            •	Icon of the app or relevant user image
            •	Title and message
            •	Timestamp

    o Creating a Notification
        NotificationCompat.Builder mBuilder =
                new NotificationCompat.Builder(this)
                .setSmallIcon(R.drawable.notification_icon)
                .setContentTitle("My notification")
                .setContentText("Hello World!");

        NotificationManager mNotificationManager =
            (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        // mId allows you to update the notification later on.
        mNotificationManager.notify(mId, mBuilder.build());


    o Adding an Action
        Notifications can also have actions attached that the user can perform by clicking.
        Although having an action attached to the notification is optional,
        you should almost always have at least one action attached.
        The action inside the notification should be a PendingIntent which will fire when the user presses on the notification item.

        // First let's define the intent to trigger when notification is selected
        // Start out by creating a normal intent (in this case to open an activity)
        Intent intent = new Intent(this, SomeActivity.class);
        // Next, let's turn this into a PendingIntent using
        //   public static PendingIntent getActivity(Context context, int requestCode,
        //       Intent intent, int flags)
        int requestID = (int) System.currentTimeMillis();
        //unique requestID to differentiate between various notification with same NotifId
        int flags = PendingIntent.FLAG_CANCEL_CURRENT; // cancel old intent and create new one
        PendingIntent pIntent = PendingIntent.getActivity(this, requestID, intent, flags);
        // Now we can attach the pendingIntent to a new notification using setContentIntent
        Notification noti = new NotificationCompat.Builder(this)
                .setSmallIcon(R.drawable.notification_icon)
                .setContentTitle("My notification")
                .setContentText("Hello World!")
                .setContentIntent(pIntent)
                .setAutoCancel(true) // Hides the notification after its been selected
                .build();
        // Get the notification manager system service
        NotificationManager mNotificationManager =
            (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        // mId allows you to update the notification later on.
        mNotificationManager.notify(0, noti);


    o Adding an Expanded View
        Notification noti = new NotificationCompat.Builder(this).
        .....
        .setStyle(new NotificationCompat.BigTextStyle().bigText(longText))

    o Canceling Notifications
        // Store some notification id as `nId`
        NotificationManager mNotificationManager =
          (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
        mNotificationManager.cancel(nId);

    o Adding a Large Icon
        // .setLargeIcon expects a bitmap
        Bitmap largeIcon = BitmapFactory.decodeResource(getResources(),
            R.drawable.my_large_icon);
        // Pass in the bitmap as the large icon
        NotificationCompat.Builder mBuilder = new NotificationCompat.Builder(this)
            ...
            .setLargeIcon(largeIcon);

-----------------------------------------------------------------
    Storing and Accessing SharedPreferences
        o Storing Data with SharedPreferences
            Specifying a Preference File
                SharedPreferences mSettings = getActivity().getSharedPreferences("Settings", 0);
            Using a Default Preferences File
                SharedPreferences mSettings = PreferenceManager.getDefaultSharedPreferences(getActivity());
                Using this way will default the preference file to be stored as
                /data/data/com.package.name/shared_prefs/com.package.name_preferences.xml
        o Editing Preferences
        SharedPreferences.Editor editor = mSettings.edit();
            int id = 1;
            String username = "john";
            editor.putString("username", username);
            editor.putInt("id", id);
            editor.apply();
        o Accessing Stored Data from SharedPrefrences
            SharedPreferences mSettings = getActivity().getSharedPreferences("Settings", 0);
            String cookieName = mSettings.getString("cookieName", "missing");

        commit() writes the data synchronously and returns a boolean value of success or failure depending on the result immediately.
        apply() is asynchronous and it won’t return any boolean response. Also if there is an apply() outstanding and
        we perform another commit().
        The commit() will be blocked until the apply() is not completed.

-----------------------------------------------------------------
Managing Threads and Custom Services
        A thread is a single sequential flow of control within a program.
        Threads can be thought of as mini-processes running within a main process.

        Thread Management :
            o Using an AsyncTask:
                • Description : Sequentially runs short tasks updating the UI
                • Built On : ThreadPoolExecutor
            o Using a HandlerThread:
                • Description : Sequentially runs tasks on a single thread
                • Built On : Handler, Looper
            o Executing Runnables on HandlerThread:
                • Description : Concurrently runs tasks using a thread pool
                • Built On : Executor, ExecutorService

      o 1 Async Tasks
                AsyncTask allows you to perform asynchronous work on your user interface.
                It performs the blocking operations in a worker thread and then publishes the results on the UI thread,
                without requiring you to handle threads and/or handlers yourself.

                AsyncTask allows for short sequential tasks to be performed within an activity context
                in the easiest way possible. Often the AsyncTask is used to run a background task,
                report progress and then update the UI thread with the results.

            1.	Pre - Execute code on the UI thread before starting a task (e.g show ProgressBar)
            2.	Task - Run a background task on a thread given certain inputs (e.g fetch data)
            3.	Updates - Display progress updates during the task (optional)
            4.	Post - Execute code on UI thread following completion of the task (e.g show data)

        AsyncTask accepts three generic types to inform the background work being done:
        •	AsyncTask<Params, Progress, Result>
            o	Params - the type that is passed into the execute() method.
            o	Progress - the type that is used within the task to track progress.
            o	Result - the type that is returned by doInBackground().

        AsyncTask has multiple events that can be overridden to control different behavior:
            •	onPreExecute - executed in the main thread to do things like create the initial progress bar view.
            •	doInBackground - executed in the background thread to do things like network downloads.
            •	onProgressUpdate - executed in the main thread when publishProgress is called from doInBackground.
            •	onPostExecute - executed in the main thread to do things like set image views.

      o 2 Using a HandlerThread
            HandlerThread is a handy class for starting up a new worker thread that sequentially runs tasks.
            If you need a single background thread that starts a loop capable of running code or processing messages
            in the order that they arrive, this is the tool for the job.

                // Create a new background thread for processing messages or runnables sequentially
                HandlerThread handlerThread = new HandlerThread("HandlerThreadName");
                // Starts the background thread
                handlerThread.start();
                // Create a handler attached to the HandlerThread's Looper
                mHandler = new Handler(handlerThread.getLooper()) {
                    @Override
                    public void handleMessage(Message msg) {
                        // Process received messages here!
                    }
                };
          o Executing Runnables on HandlerThread
                Once the HandlerThread is started, we can execute code on the worker thread through the Handler:
                // Execute the specified code on the worker thread
                mHandler.post(new Runnable() {
                    @Override
                    public void run() {
                        // Do something here!
                    }
                });

                Method	                Description
                post	            Immediately enqueue Runnable to be executed.
                postAtTime	        Enqueue Runnable to execute at absolute time specified in millis.
                postDelayed	        Enqueue Runnable to execute after the specified delay in millis.
                postAtFrontOfQueue	Immediately enqueue Runnable to the front to be executed.

          o Processing Messages on HandlerThread
                Rather than running arbitrary code on the background thread using a Runnable as shown above,
                Handler can also enqueue messages with bundled information.
                    the worker thread through the Handler:
                    // Secure a new message to send
                    Message message = handler.obtainMessage();
                    // Create a bundle
                    Bundle b = new Bundle();
                    b.putString("message", "foo");
                    // Attach bundle to the message
                    message.setData(b);
                    // Send message through the handler
                    mHandler.sendMessage(message);
                    // or instead send an empty message with
                    // mHandler.sendEmptyMessage(0);

                    Method	                   Description
                    sendMessage	            Pushes a message onto the end of the message queue.
                    sendMessageDelayed	    Pushes a message onto the end of the message queue.
                    sendMessageAtTime	    Pushes a message onto the end of the message queue.
                    sendEmptyMessage	    Sends Message containing only a single int code.
                    sendEmptyMessageDelayed	Sends Message to be delivered after the specified time elapses.
                    sendEmptyMessageAtTime	Sends Message to be delivered at the specified absolute time.

          o Stopping the HandlerThread :
                The worker thread can be stopped immediately with:
                handlerThread.quit(); // quits immediately
          o HandlerThread Caveats :
                HandlerThread is great for running tasks linearly (sequentially) on a thread and affords
                the developer control over how and when messages and runnables are processed by exposing
                access to the underlying Looper and Handler.


      o 3 Using a ThreadPoolExecutor
            • Constructing the ThreadPoolExecutor
              Using a ThreadPoolExecutor starts with constructing a new instance along with many arguments configuring the thread pool:
              // Determine the number of cores on the device
              int NUMBER_OF_CORES = Runtime.getRuntime().availableProcessors();
              // Construct thread pool passing in configuration options
              // int minPoolSize, int maxPoolSize, long keepAliveTime, TimeUnit unit,
              // BlockingQueue<Runnable> workQueue
              ThreadPoolExecutor executor = new ThreadPoolExecutor(
                  NUMBER_OF_CORES*2,
                  NUMBER_OF_CORES*2,
                  60L,
                  TimeUnit.SECONDS,
                  new LinkedBlockingQueue<Runnable>()
              );
              If you are initializing ThreadPoolExecutor within a service, make sure to create it within onStartCommand().
              Putting it in onCreate() will likely trigger RequestRejectedException errors.

            • Executing Runnables on ThreadPoolExecutor
                we can queue up a Runnable code block to execute on a thread in the pool with:
                // Executes a task on a thread in the thread pool
                executor.execute(new Runnable() {
                    public void run() {
                        // Do some long running operation in background
                        // on a worker thread in the thread pool!
                    }
                });
                Threads are used to process each runnable concurrently as the message is received until all threads are busy.
                If all threads are currently busy, the Executor will queue a new task until a thread becomes available.

            • Stopping the ThreadPoolExecutor
                The thread pool can be shutdown any time with the shutdown command:
                executor.shutdown();

                This will shutdown the executor safely once all runnables have been processed.
                To shut down the executor immediately, instead use executor.shutdownNow().


            Threading Glossary
     Name	                    Description
     Runnable	        Represents code that can be executed on any Thread.
     Thread	            Concurrent unit of execution which runs code specified in a Runnable
     Message	        Represents data that can be sent or received through a Handler
     Handler	        Processes Runnable or Message objects on a Thread.
     Looper	            Loop that processes and sends Runnable or Message objects to a Handler
     MessageQueue	    Stores the list of Runnable or Message objects dispatched by the Looper

      Runnable
        A Runnable represents code that can be executed on a thread usually scheduled through a Handler.
        Runnables is an abstract class that has a run method to implement.

        Runnable taskToRun = new Runnable() {
            @Override
            public void run() {
                // The code to execute when the runnable is processed by a thread
            }
        };

      Thread
        A Thread is a concurrent unit of execution which runs code specified in a Runnable.
        The Runnable defined above taskToRun can be executed using a Thread:

        // Start a new thread to execute the runnable codeblock
        Thread thread = new Thread(taskToRun);
        thread.start();

      Handler and Loopers
        A Handler manages the sending and processing of Message (data) or Runnable (code) objects to a Looper
        which is continuously enqueuing and processing incoming messages.
            1.	Handler enqueues a Message or Runnable object onto the MessageQueue
            2.	Looper dequeues Messages off the MessageQueue in sequential order
            3.	Looper dispatches the Message or Runnable to the Handler to be processed

        . A Handler can therefore also be used to post code to be run on the main thread from any other threads running:

        // Create a handler attached to the UI Looper
        Handler handler = new Handler(Looper.getMainLooper());
        // Post code to run on the main UI Thread (usually invoked from worker thread)
        handler.post(new Runnable() {
             public void run() {
                  // UI code goes here
             }
        });

        // From within an Activity,
        // usually executed within a worker thread to update UI
        runOnUiThread(new Runnable(){
             public void run() {
                  // UI code goes here
             }
        });





-----------------------------------------------------------------
RecyclerView:
    In Android, RecyclerView is an advanced and flexible version of ListView and GridView.
    It is a container used for displaying large amount of data sets that can be scrolled very efficiently by maintaining
    a limited number of views. RecyclerView was introduced in Material Design in API level 21
    In Android, RecyclerView provides an ability to implement the horizontal, vertical and Expandable List.

    listview vs recyclerview
    1. RecyclerView uses a ViewHolder for storing the reference of the view for one entry in the RecyclerView.
       use ListView or GridView for displaying custom items then we create a custom xml file and then use it inside our Adapter.
       For this we create a CustomAdapter class and then extends our Base or any other Adapter in it.
       In getView() method of our Adapter we inflate the item layout xml file and then give the reference of every view by using the
        unique id’s we provide in our xml file .
        Once finished we pass that view to the ListView, ready to be drawn, but the truth is that ListView
        and GridView do only half the job of achieving true memory efficiency.

    2. ListView/GridView recycle the item layout but don’t keep the reference to the layout children, forcing us to call findViewById()
    for every child of our item layout for every time we call getView(). This issue causes the scrolling or non responsive problem as
    it frantically tries to grab references to the view’s we needed.

    3. With the arrival of RecyclerView everything is changed. RecyclerView still uses Adapter to act as Data source but in this
    we have to create a ViewHolder to keep the reference of View in memory, so when we need a new view it either creates a new
    ViewHolder object to inflate the layout and hold those references or it recycles one from existing stack.





1. recycler view with default data set
2. recycler view with dynamic data set
3. recycler view with custom data model
4. recycler view with homogeneous layouts
5. recycler view with heterogeneous layouts
6. recycler view swipe to refresh
7. recyclerview add and remove dynamically


If you want to use a RecyclerView, you will need to work with the following:
Components of RecyclerView In Android

    1. LayoutManager - Helps in positioning the items
                       Linear Layout Manager – It is used for displaying the data items in a horizontal or vertical scrolling List
                                LinearLayoutManager(Context context, int orientation, boolean reverseLayout)
                       GridLayoutManager – It is used to show the items in grid format
                       StaggeredGridLayoutManager – It is used to show the items in staggered Grid.
    2. ViewHolder:
    3. RecyclerView.Adapter: To handle the data collection and bind it to the view.
                            override: 1. onCreateViewHolder: inflate the view
                                      2. onBindViewHolder: bind the data to the view
                                      3. getItemCount()

    4. ItemAnimator - Helps with animating the items for common operations such as Addition or Removal of item


The most important classes of the RecyclerView API
Class 	        Usage
Adapter 	    Wraps the data set and creates views for individual items
ViewHolder  	Holds all sub views that depend on the current item's data
LayoutManager 	Places items within the available area
ItemDecoration 	Draws decorations around or on top of each item's view
ItemAnimator 	Animates items when they are added, removed or reordered



-----------------------------------------------------------------



-----------------------------------------------------------------



-----------------------------------------------------------------
                        Android Testing Options
    Unit Testing
        •	Robolectric - Popular Android unit test framework that allows faster test execution by running tests on the JVM
                            (no device or emulator needed).
        •	JUnit - Popular Java unit test framework. Most of the Android test frameworks are built on top of JUnit.

    Instrumentation Testing:
        •	Espresso - Extensible Android UI Test Framework provided by Google that handles test synchronization very well.
        •	UIAutomator - Android UI Test Framework provided by Google for testing across multiple apps at the same time.
        •	Google Android Testing - This is the testing framework included as part of the platform.
        •	Robotium - Third party Android UI Test Framework (comparison with Espresso)
        •	Selendroid - Selenium for Android

    Richer Validation Support : Simple JUnit assertions leave a lot to be desired when working on Android. The following libraries and
                                classes help fill this gap.
        •	Assertj-Android - An extension of AssertJ (fluent assertions for Java) extended for Android (formerly known as FEST Android).
        •	MoreAsserts - Extension of JUnit assertions to add assertions for sets, lists, etc.
        •	ViewAsserts - Helper methods to validate view layout

    Mocking Frameworks
        •	Mockito - Popular mocking framework for Java
        •	EasyMock - Mocking framework that has record / replay support

    Tools
        •	Cloud Test Lab - Large bank of devices where you can submit your tests and have them run across different devices.
        •	MonkeyRunner - API Toolkit that allows controlling the Android device from Python code.
        •	Monkey - Program that runs on the device and performs random clicks, text input, etc.
        •	Spoon - Run your tests across multiple devices at the same time and see aggregated reports / screenshots.



-----------------------------------------------------------------
                            Must Have Libraries
            Standard Pack
    Name	              Description
    Retrofit        A type-safe REST client for Android which intelligently maps an API into a client interface using annotations.
    Glide           A powerful image downloading and caching library for Android.
    ButterKnife     Using Java annotations, makes Android development better by simplifying common tasks.
    Parceler        Android Parcelable made easy through code generation
    IcePick         Android Instance State made easy
    LeakCanary      Catch memory leaks in your apps
    Espresso        Powerful DSL for Android integration testing
    Robolectric     Efficient unit testing for Android


            Advanced Pack
    Name	                 Description
    Dagger 2            A fast dependency injector for managing objects.
    RxJava              Develop fully reactive components for Android.
    EventBus            Android event bus for easier component communication.
    AndroidAnnotations  Powerful annotations to reduce boilerplate code.
    Retrolambda         Bringing lambda block support to Android.

    Parceler and IcePick
    ButterKnife and Parceler
    ButterKnife and Custom Views


                    Convenience
•	Dagger -            A fast dependency injector for Android and Java. See this video intro from Square.
•	Spork -             Spork is an annotation processing library to speed up development on your projects. It allows you to
                        write less boilerplate code to make your code more readable and maintainable.
•	AutoParcel -        Port of Google AutoValue for Android with Parcelable generation goodies.
•	Hugo -              Easier logging within your app
•	Logger -            Much cleaner and easier logcat trace messages
•	LeakCanary -        Easily catch memory leaks as they occur
•	AndroidAnnotations - Framework that speeds up Android development. It takes care of the plumbing, and lets you concentrate on what's really important.
By simplifying your code, it facilitates its maintenance
•	Calligraphy -       Custom fonts made easy
•	EasyFonts -         Easy preloaded custom fonts in your app
•	AndroidViewAnimations - Common property animations made easy
•	AboutLibraries -    Automatically generates an About this app section, with a list of used libraries
•	SDK Manager Plugin - Helpful plugin especially for group projects if you're missing an SDK version,
                            haven't downloaded an API version, or your support library is updated.
•	EasyDeviceInfo -    Get device information in a super easy way

                    Extensions
•	RxJava - Reactive Extensions for the JVM
•	EventBus - Android optimized event bus that simplifies communication between components.
•	Tape - Tape is a collection of queue-related classes for Android and Java
•	Priority Job Queue - Easier background tasks
•	ACRA - Crash reporting made easy and free. Check the setup instructions and open-source backend.

                    Networking
•	Retrofit - A type-safe REST client for Android and Java which intelligently maps an API into a client interface using annotations.
•	Picasso - A powerful image downloading and caching library for Android.
•	Ion - Powerful asynchronous networking library. Download as a jar here.
•	Android Async HTTP - Asynchronous networking client for loading remote content such as JSON.
•	Volley - Google's HTTP library that makes networking for Android apps easier and most importantly, faster.
•	OkHttp - Square's underlying networking library with support for asynchronous requests.
•	Glide - Picasso image loading alternative endorsed by Google
•	Android Universal Image Loader - Popular alternative for image loading that can replace Picasso or Glide.
•	Fresco - An image management library from Facebook.
•	Fast Android Networking -Fast Android Networking is a powerful library for doing any type of networking in
                             Android applications which is made on top of OkHttp Networking Layer.

                    ListView
•	EasyListViewAdapters - Building multi-row-type listview made much cleaner & easier.
•	GridListViewAdapters - Easily build unlimited Grid cards list like play-store. (ListView working as unlimited GridView)
•	StickyListHeaders - An android library for section headers that stick to the top of a ListView
•	PinnedListView - Pinned Section with ListView
•	ListViewAnimations - Easy way to animate ListView items
•	Cardslib - Card UI for Lists or Grids
•	PullToRefresh-ListView - Easy to use pull-to-refresh functionality for ListViews. Download and install as a library project.
•	QuickReturn - Reveal or hide a header or footer as the list is scrolled in a direction.
•	Paginated Table - This is a table which allows dynamic paging for any list of objects. Icons can be added to columns as well
                        as custom items such as check boxes and buttons.

                    RecyclerView
•	UltimateRecyclerView - Augmented RecyclerView with refreshing, loading more, animation and many other features.
•	AdvRecyclerView - Extended RecyclerView with swipe to dismiss, and draggable or expanding items.
•	android-parallax-recyclerview - An adapter which could be used to achieve a parallax effect on RecyclerView.
•	sticky-headers-recyclerview - Sticky Headers decorator for Android's RecyclerView.
•	FastAdapter - Simplify and speed up the process of filling your RecyclerView with data
•	ItemAnimators - RecyclerView animators to animate item add/remove/add/move
•	GreedoLayout - Full aspect ratio grid LayoutManager for Android's RecyclerView
•	RecyclerViewHelper - Provides the most common functions around recycler view like Swipe to dismiss, Drag and Drop, Divider in the ui,
                         events for when item selected and when not selected, on-click listener for items.

                    Easy Navigation
•	JazzyViewPager - Pager with more animations
•	ParallaxPager - ViewPager with Parallax scrolling effects
•	ParallaxHeaderViewPager - Another ViewPager with Parallax scrolling effects
•	ParallaxPagerTransformer - A pager transformer for Android with parallax effect
•	SlidingMenu - Library that allows developers to easily create applications with sliding menus like those made popular in the Google+,
                    YouTube, and Facebook apps.
•	Android Satellite Menu - Radial menu which is configurable reminiscent of the "Path" menu style.
•	ArcMenu - Alternate radial menu modeled after the "Path" menu style.
•	AndroidSlidingUpPanel - Sliding Up Panel
•	DraggablePanel - Panels that can be dragged
•	MaterialDrawer - Easily add a Navigation Drawer with Material style and AccountSwitcher

                    UI Components
•	SparkButton - Library to create buttons with Twitter's heart like animation.
•	Crouton - Context-sensitive, configurable alert notices much better than toasts. Download jar from here. See working sample code
•	BetterPickers - BetterPickers for easy input selection
•	android-shape-imageview - Custom shaped android imageview components including bubble, star, heart, diamond.
•	RoundedImageView - Easily round corners or create oval-shaped images with this popular library.
•	Android StackBlur - Dynamically blur images
•	Android Bootstrap - Bootstrap UI widgets
•	PhotoView - ImageView that supports touch gestures
•	ShowcaseView - Highlight the best bits of your app
•	FadingActionBar - Cool actionbar fade effect
•	AndroidViewAnimations - Easily apply common animations
•	ProgressWheel - Better progress bar
•	SmoothProgressBar - Horizontal indeterminate progress
•	CircularFillableLoaders - Beautiful animated fillable loaders
•	Rebound - Easy spring dynamics
•	AndroidImageSlider - Animated image transitions
•	FloatingActionButton - Material design floating buttons made easy
•	Foursquare-CollectionPicker - Item Picker which looks like Foursquare Tastes picker
•	NexusDialog - Create form dialogs easily
•	dialogplus - Simple, easy dialogs
•	Iconify - Easily embed icons into your app
•	Android StepsView - A library to create StepsView for Android
•	PhotoView - A library to pinch zoom in and zoom out and double tap zoom for Android
•	Android-Iconics - Add many scalable and styleable icons into your app
•	Scissors - An easy image cropping library developed by Lyft.
•	Material-SearchView - Beautiful Material SearchView made simple.
•	PersistentSearchBar - Implementation of a persistent search bar.

                    Drawing
•	MPAndroidChart - A powerful Android chart view / graph view library, supporting line- bar- pie- radar- bubble- 
and candlestick charts as well as scaling, dragging and animations.
•	HoloGraphLibrary - Newer graphing library
•	EazeGraph - Another newer library with potential
•	AndroidCharts - Easy to use charts
•	AndroidGraphView - library to create flexible and nice-looking diagrams.
•	AndroidPlot - plotting library for Android
•	WilliamChart - Flexible charting library with useful motion capabilities.
•	HelloCharts - Charts/graphs library for Android with support for scaling, scrolling and animations.
•	Leonids - Simple and easy particle effects (See Tutorial)
•	AChartEngine - This is a charting software library for Android applications

                    Image Processing
•	AndroidPhotoFilters - Library to create interesting effects on any image of your choice. Comes with prebuilt great sample effects.
•	android-gpuimage - Popular GPU Image Processing
•	android-image-filter - Older image filtering library
•	picasso-transformations - Library for processing images via Picasso
•	glide-transformations - Process images via Glide
•	ImageEffectFilter - Sample code for processing images.
•	VidEffects - Apply manipulation effects to videos.

                    Scanning
•	ZXing - Barcode or QR scanner
•	ZXing Android Embedded - Alternative zxing scanner
•	barcodescanner - Newer alternative
•	CamView - ZXing alternative
•	android-quick-response-code - Another alternative

                    Persistence
•	ActiveAndroid
•	DBFlow - A robust, powerful, and very simple ORM android database library with annotation processing.
•	greenDAO
•	SugarORM
•	RxCache - Reactive caching library for Android
•	ORMLite
•	SQLBrite - Lightweight wrapper around SQLiteOpenHelper
•	Cupboard - Popular take on SQL wrapper
•	StorIO - Fresh take on a light SQL wrapper
•	Realm
•	NexusData
•	Hawk - Persistent secure key/value store
•	Poetry - Persist JSON directly into SQLite
•	JDXA - The KISS ORM for Android - Simple, Non-intrusive, and Flexible

                        Compatibility
•	NineOldAndroids - Fully compatible animation library that works with all versions of Android. Widely used. Download and install as a library project.
•	HoloEverywhere - Backport Holo theme from Android 4.2 to 2.1+
•	CropImage - Simple compatible cropping intent for images

                        Scrolling and Parallax
This is a list of popular scrolling and parallax libraries:
•	QuickReturn - Reveal or hide a header or footer as the list is scrolled in a direction.
•	ParallaxPagerTransformer - A pager transformer for Android with parallax effect
•	ParallaxHeaderViewPager - Another ViewPager with Parallax scrolling effects
•	Android-ObservableScrollView - Android library to observe scroll events on scrollable views.
•	Scrollable - Automatic scrolling logic when implementing scrolling tabs
•	ParallaxPager - ViewPager with Parallax scrolling effects
•	android-parallax-recyclerview - An adapter which could be used to achieve a parallax effect on RecyclerView.

                        Debugging
•	Stetho - A debug bridge for Android applications which could be used for multiple purposes not limited to Network Inspection,
                Database Inspection and Javascript Console.
•	Bugfender - Cloud storage for your app logs, track user behaviour to find problems in your mobile apps.



-----------------------------------------------------------------




-----------------------------------------------------------------



-----------------------------------------------------------------




-----------------------------------------------------------------
There are at least 17 types of drawables but there are five that are most important to understand:

    Shape Drawables - Defines a shape with properties such as stroke, fill, and padding
    StateList Drawables - Defines a list of drawables to use for different states
    LayerList Drawables - Defines a list of drawables grouped together into a composite result
    NinePatch Drawables - A PNG file with stretchable regions to allow proper resizing
    Vector Drawables - Defines complex XML-based vector images






-----------------------------------------------------------------






-----------------------------------------------------------------


https://data-flair.training/blogs/android-service-tutorial/